// Use Case: Create Party
import { IPartyRepository } from '../repositories/interfaces';
import { IPlayerRepository } from '../repositories/interfaces';
import { ICreatePartyUseCase } from './interfaces';
import { Party } from '../entities/Party';
import { Character } from '../entities/Character';
import { Player } from '../entities/Player';
import { Stats, Rule, Experience } from '../entities/valueObjects';
import { LevelRestrictionsService } from '../entities/LevelRestrictionsService';

export class CreatePartyUseCase implements ICreatePartyUseCase {
  constructor(
    private partyRepository: IPartyRepository,
    private playerRepository: IPlayerRepository
  ) {}

  async execute(data: { playerId: string; name: string; characters: any[] }): Promise<any> {
    try {
      // Validate input
      if (!data.playerId || !data.name || !data.characters) {
        throw new Error('Missing required fields: playerId, name, characters');
      }

      if (data.characters.length === 0) {
        throw new Error('Party must have at least one character');
      }

      // Verify player exists
      const playerData = await this.playerRepository.findById(data.playerId);
      if (!playerData) {
        throw new Error('Player not found');
      }

      // Create Player instance to use domain methods
      const player = new Player(
        playerData.id,
        playerData.username,
        playerData.level,
        new Experience(
          playerData.experience.current,
          playerData.experience.nextLevel,
          playerData.experience.total
        ),
        playerData.createdAt,
        playerData.updatedAt
      );

      // Check party limits based on player level
      const existingPartiesCount = await this.partyRepository.countByPlayerId(data.playerId);
      const maxParties = this.getMaxPartiesForLevel(player.level);

      if (existingPartiesCount >= maxParties) {
        throw new Error(`Player level ${player.level} can only have ${maxParties} parties`);
      }

      // Validate character limit
      if (!player.canCreateParty(data.characters.length)) {
        throw new Error(`Player level ${player.level} can only have up to ${this.getMaxCharactersForLevel(player.level)} characters per party`);
      }

      // Convert character data to Character entities
      const characters: Character[] = data.characters.map(charData => {
        const rules = charData.rules ? charData.rules.map((ruleData: any) =>
          new Rule(ruleData.id, ruleData.priority, ruleData.condition, ruleData.target, ruleData.action)
        ) : [];

        return new Character(
          charData.id,
          charData.name,
          charData.job,
          charData.level,
          new Stats(
            charData.stats.hp,
            charData.stats.mp,
            charData.stats.str,
            charData.stats.def,
            charData.stats.mag,
            charData.stats.spd
          ),
          charData.skills || [],
          rules
        );
      });

      // Create temporary party for validation
      const tempParty = new Party(
        '', // ID will be generated by database
        data.playerId,
        data.name,
        characters,
        new Date(),
        new Date()
      );

      // Validate party restrictions using LevelRestrictionsService
      const validation = LevelRestrictionsService.validatePartyRestrictions(player, tempParty);
      if (!validation.isValid) {
        throw new Error(validation.message);
      }

      // Create party
      const party = new Party(
        '', // ID will be generated by database
        data.playerId,
        data.name,
        characters,
        new Date(),
        new Date()
      );

      // Save to database
      const savedParty = await this.partyRepository.save(party);

      return savedParty;

    } catch (error) {
      console.error('Error creating party:', error);
      throw error;
    }
  }

  private getMaxPartiesForLevel(level: number): number {
    // Level 1-2: 1 party, Level 3-5: 2 parties, Level 6+: 3 parties
    if (level <= 2) return 1;
    if (level <= 5) return 2;
    return 3;
  }

  private getMaxCharactersForLevel(level: number): number {
    // Level 1: 2 characters, Level 2-3: 3 characters, Level 4+: 4 characters
    if (level === 1) return 2;
    if (level <= 3) return 3;
    return 4;
  }
}